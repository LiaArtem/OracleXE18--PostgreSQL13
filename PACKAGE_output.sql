-- Generated by Ora2Pg, the Oracle database Schema converter, version 21.1
-- Copyright 2000-2020 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=DESKTOP-KNCPJAN;sid=XE;port=1521

SET client_encoding TO 'UTF8';

SET search_path = test_user,public;


-- Oracle package 'P_CHECK' declaration, please edit to match PostgreSQL syntax.

DROP SCHEMA IF EXISTS p_check CASCADE;
CREATE SCHEMA IF NOT EXISTS p_check;

CREATE TYPE t_kurs_nbu_row AS (
r030         varchar(3),
 txt          varchar(255),
 rate         numeric,
 cc           varchar(3),
 exchangedate timestamp

);

CREATE TYPE t_kurs_nbu_table AS (t_kurs_nbu_table t_kurs_nbu_row[]);


CREATE TYPE t_isin_secur_row AS (
cpcode          varchar(255),
  nominal         numeric,                                      
  auk_proc        numeric,                                      
  pgs_date        timestamp,                                      
  razm_date       timestamp,                                      
  cptype          varchar(255),
  cpdescr         varchar(255),
  pay_period      numeric,                                      
  val_code        varchar(3),                                      
  emit_okpo       varchar(255),
  emit_name       varchar(255),
  cptype_nkcpfr   varchar(255),
  cpcode_cfi      varchar(255),
  total_bonds     numeric,
  pay_date        timestamp,
  pay_type        numeric,
  pay_val         numeric,
  pay_array       varchar(5)  

);

CREATE TYPE t_isin_secur_table AS (t_isin_secur_table t_isin_secur_row[]);


CREATE TYPE t_fair_value_row AS (
calc_date         timestamp,
 cpcode            varchar(255),
 ccy               varchar(3),
 fair_value        numeric,
 ytm               numeric,
 clean_rate        numeric,
 cor_coef          numeric,
 maturity          timestamp,
 cor_coef_cash     numeric,
 notional          numeric,
 avr_rate          numeric,
 option_value      numeric,
 intrinsic_value   numeric,
 time_value        numeric,
 delta_per         numeric,
 delta_equ         numeric,
 dop               varchar(255)

);

CREATE TYPE t_fair_value_table AS (t_fair_value_table t_fair_value_row[]);


CREATE TYPE sys_plsql_3e4f94b_9_1 AS (
CALC_DATE timestamp,
CPCODE varchar(255),
CCY varchar(3),
FAIR_VALUE numeric,
YTM numeric,
CLEAN_RATE numeric,
COR_COEF numeric,
MATURITY timestamp,
COR_COEF_CASH numeric,
NOTIONAL numeric,
AVR_RATE numeric,
OPTION_VALUE numeric,
INTRINSIC_VALUE numeric,
TIME_VALUE numeric,
DELTA_PER numeric,
DELTA_EQU numeric,
DOP varchar(255)
);

CREATE TYPE sys_plsql_3e4f94b_dummy_1 AS (sys_plsql_3e4f94b_dummy_1 numeric[]);

CREATE TYPE sys_plsql_3e4f94b_103_1 AS (sys_plsql_3e4f94b_103_1 "TEST_USER"."SYS_PLSQL_3E4F94B_9_1"[]);


CREATE TYPE sys_plsql_3e4f94b_111_1 AS (
CPCODE varchar(255),
NOMINAL numeric,
AUK_PROC numeric,
PGS_DATE timestamp,
RAZM_DATE timestamp,
CPTYPE varchar(255),
CPDESCR varchar(255),
PAY_PERIOD numeric,
VAL_CODE varchar(3),
EMIT_OKPO varchar(255),
EMIT_NAME varchar(255),
CPTYPE_NKCPFR varchar(255),
CPCODE_CFI varchar(255),
TOTAL_BONDS numeric,
PAY_DATE timestamp,
PAY_TYPE numeric,
PAY_VAL numeric,
PAY_ARRAY varchar(5)
);

CREATE TYPE sys_plsql_3e4f94b_222_1 AS (sys_plsql_3e4f94b_222_1 "TEST_USER"."SYS_PLSQL_3E4F94B_111_1"[]);


CREATE TYPE sys_plsql_3e4f94b_230_1 AS (
R030 varchar(3),
TXT varchar(255),
RATE numeric,
CC varchar(3),
EXCHANGEDATE timestamp
);

CREATE TYPE sys_plsql_3e4f94b_264_1 AS (sys_plsql_3e4f94b_264_1 "TEST_USER"."SYS_PLSQL_3E4F94B_230_1"[]);


CREATE TYPE sys_plsql_3e4f94b_272_1 AS (
ISSUCCESS varchar(5),
NUM_ROWS numeric,
REQUESTDATE timestamp,
ISOVERFLOW varchar(5),
NUM_ID numeric,
ROOT_ID numeric,
LASTNAME varchar(4000),
FIRSTNAME varchar(4000),
MIDDLENAME varchar(4000),
BIRTHDATE varchar(255),
PUBLISHER varchar(4000),
DEPARTMENTCODE varchar(4000),
DEPARTMENTNAME varchar(4000),
DEPARTMENTPHONE varchar(4000),
EXECUTOR varchar(4000),
EXECUTORPHONE varchar(4000),
EXECUTOREMAIL varchar(4000),
DEDUCTIONTYPE varchar(4000),
VPNUM varchar(4000),
OKPO varchar(255),
FULL_NAME varchar(4000)
);

CREATE TYPE sys_plsql_3e4f94b_414_1 AS (sys_plsql_3e4f94b_414_1 "TEST_USER"."SYS_PLSQL_3E4F94B_272_1"[]);


CREATE TYPE t_erb_minfin_row AS (
isSuccess       varchar(5),
 num_rows        numeric,
 requestDate     timestamp,
 isOverflow      varchar(5),
 num_id          numeric,
 root_id         numeric,
 lastname        varchar(4000),
 firstname       varchar(4000),
 middlename      varchar(4000),
 birthdate       varchar(255),
 publisher       varchar(4000),
 departmentcode  varchar(4000),
 departmentname  varchar(4000),
 departmentphone varchar(4000),
 executor        varchar(4000),
 executorphone   varchar(4000),
 executoremail   varchar(4000),
 deductiontype   varchar(4000),
 vpnum           varchar(4000),
 okpo            varchar(255),
 full_name       varchar(4000) 

);

CREATE TYPE t_erb_minfin_table AS (t_erb_minfin_table t_erb_minfin_row[]);




-- Проверка валидности JSON
CREATE OR REPLACE FUNCTION p_check.is_valid_json (p_text text) RETURNS varchar AS $body$
DECLARE

      p_is_valid varchar(1);

BEGIN
        select CASE WHEN count(*)=0 THEN 'F'  ELSE 'T' END  into STRICT p_is_valid
        from (
        SELECT p_text as t
        
        ) tt
        where (CASE WHEN tt.t::json IS NULL THEN true ELSE true END); -- валидация json
        return p_is_valid;
    end;

    -- Проверка валидности XML
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION p_check.is_valid_json (p_text text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_check.is_valid_xml (p_text text) RETURNS varchar AS $body$
DECLARE

        p_xml xml;

BEGIN
        p_xml := xmltype(p_text);
        return 'T';
    exception when others
    then
        return 'F';
    end;

$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_check.is_valid_xml (p_text text) FROM PUBLIC;
-- End of Oracle package 'P_CHECK' declaration



-- Oracle package 'P_CONVERT' declaration, please edit to match PostgreSQL syntax.

DROP SCHEMA IF EXISTS p_convert CASCADE;
CREATE SCHEMA IF NOT EXISTS p_convert;



-- Преобразование из base64 (до 32000 символов)
CREATE OR REPLACE FUNCTION p_convert.base64_decode (p_value text) RETURNS varchar AS $body$
BEGIN
    if p_value is null then return null; end if;
    return utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(p_value)));
  end;

  -- Преобразование из base64 (clob)
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION p_convert.base64_decode (p_value text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.base64_decode_clob (p_payload_clob text) RETURNS text AS $body$
DECLARE

    m_send_payload_temp text;
    m_send_payload      text;
    m_buffer            integer := 8184;
    m_data              varchar(32736);
    m_len               integer;
    m_start             integer := 1;

BEGIN
    m_len := octet_length(p_payload_clob);
    if m_len > 0 then
       dbms_lob.createtemporary(m_send_payload_temp, true);
       if m_len < m_buffer then
          m_send_payload_temp := p_convert.base64_decode(p_payload_clob);
       else
          for i in 1..ceil(m_len / m_buffer)
          loop
            m_data := substr(p_payload_clob, m_buffer, m_start);
            m_data := p_convert.base64_decode(m_data);
            dbms_lob.writeappend(m_send_payload_temp, length(m_data), m_data);
            m_start := m_start + m_buffer;
          end loop;
       end if;

       m_send_payload := m_send_payload_temp;
       dbms_lob.freetemporary(lob_loc => m_send_payload_temp);
    end if;
    return m_send_payload;
  end;

  -- Преобразование в base64 (до 32000 символов)
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.base64_decode_clob (p_payload_clob text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.base64_encode (p_value text) RETURNS varchar AS $body$
DECLARE

    m_result varchar(32736);

BEGIN
    if p_value is null then return null; end if;
    m_result := utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(p_value)));
    m_result := replace(m_result, chr(13)||chr(10), '');

    return m_result;
  end;

  -- Преобразование в base64 (clob)
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.base64_encode (p_value text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.base64_encode_clob (p_payload_clob text) RETURNS text AS $body$
DECLARE

    m_send_payload_temp text;
    m_send_payload      text;
    m_buffer            integer := 8184;
    m_data              varchar(32736);
    m_len               integer;
    m_start             integer := 1;

BEGIN
    m_len := octet_length(p_payload_clob);
    if m_len > 0 then
       dbms_lob.createtemporary(m_send_payload_temp, true);
       if m_len < m_buffer then
          m_send_payload_temp := p_convert.base64_encode(p_payload_clob);
       else
          for i in 1..ceil(m_len / m_buffer)
          loop
            m_data := substr(p_payload_clob, m_buffer, m_start);
            m_data := p_convert.base64_encode(m_data);
            dbms_lob.writeappend(m_send_payload_temp, length(m_data), m_data);
            m_start := m_start + m_buffer;
          end loop;
       end if;

       m_send_payload := m_send_payload_temp;
       dbms_lob.freetemporary(lob_loc => m_send_payload_temp);
    end if;
    return m_send_payload;
  end;

  -- Преобразование суммы в текст (с валютой)
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.base64_encode_clob (p_payload_clob text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.str_amount_curr (p_amount numeric, p_curr_code text default 'UAH', p_is_decimal char default 'F') RETURNS varchar AS $body$
DECLARE

    type WordType is table of varchar(30) index by integer;
    dig       WordType;
    dig_a     WordType;
    ten       WordType;
    hun       WordType;
    tis       WordType;
    mln       WordType;
    mlrd      WordType;
    i         numeric := 0;
    CurrValue numeric;
    OriginVal numeric;
    Fraction  numeric;
    l         numeric;
    S         numeric;
    DIGIT     varchar(255);
    RADIX     varchar(255);
    CResult   varchar(20);
    p_result    varchar(255);

BEGIN  
    CurrValue := trunc(p_amount);
    OriginVal := CurrValue;
    Fraction  := trunc((p_amount - CurrValue) * 100);

    -- тысячи
    tis(0) := 'тисяч ';
    tis(1) := 'тисяча ';
    tis(2) := 'тисячi ';
    tis(3) := 'тисячi ';
    tis(4) := 'тисячi ';
    tis(5) := 'тисяч ';
    tis(6) := 'тисяч ';
    tis(7) := 'тисяч ';
    tis(8) := 'тисяч ';
    tis(9) := 'тисяч ';
    tis(10) := 'тисяч ';
    tis(11) := 'тисяч ';
    tis(12) := 'тисяч ';
    tis(13) := 'тисяч ';
    tis(14) := 'тисяч ';
    tis(15) := 'тисяч ';
    tis(16) := 'тисяч ';
    tis(17) := 'тисяч ';
    tis(18) := 'тисяч ';
    tis(19) := 'тисяч ';

    -- мiльйон
    mln(0) := 'мiльйонiв ';
    mln(1) := 'мiльйон ';
    mln(2) := 'мiльйона ';
    mln(3) := 'мiльйона ';
    mln(4) := 'мiльйона ';
    mln(5) := 'мiльйонiв ';
    mln(6) := 'мiльйонiв ';
    mln(7) := 'мiльйонiв ';
    mln(8) := 'мiльйонiв ';
    mln(9) := 'мiльйонiв ';
    mln(10) := 'мiльйонiв ';
    mln(11) := 'мiльйонiв ';
    mln(12) := 'мiльйонiв ';
    mln(13) := 'мiльйонiв ';
    mln(14) := 'мiльйонiв ';
    mln(15) := 'мiльйонiв ';
    mln(16) := 'мiльйонiв ';
    mln(17) := 'мiльйонiв ';
    mln(18) := 'мiльйонiв ';
    mln(19) := 'мiльйонiв ';

    -- мiльярдiв
    mlrd(0) := ' ';
    mlrd(1) := 'мiльярд ';
    mlrd(2) := 'мiльярда ';
    mlrd(3) := 'мiльярда ';
    mlrd(4) := 'мiльярда ';
    mlrd(5) := 'мiльярдiв ';
    mlrd(6) := 'мiльярдiв ';
    mlrd(7) := 'мiльярдiв ';
    mlrd(8) := 'мiльярдiв ';
    mlrd(9) := 'мiльярдiв ';
    mlrd(10) := 'мiльярдiв ';
    mlrd(11) := 'мiльярдiв ';
    mlrd(12) := 'мiльярдiв ';
    mlrd(13) := 'мiльярдiв ';
    mlrd(14) := 'мiльярдiв ';
    mlrd(15) := 'мiльярдiв ';
    mlrd(16) := 'мiльярдiв ';
    mlrd(17) := 'мiльярдiв ';
    mlrd(18) := 'мiльярдiв ';
    mlrd(19) := 'мiльярдiв ';

    Dig(0) := '';
    dig(1) := 'один ';
    dig(2) := 'два ';
    dig(3) := 'три ';
    dig(4) := 'чотири ';
    dig(5) := 'п''ять ';
    dig(6) := 'шiсть ';
    dig(7) := 'сiм ';
    dig(8) := 'вiсiм ';
    dig(9) := 'дев''ять ';
    dig(10) := 'десять ';
    dig(11) := 'одинадцять ';
    dig(12) := 'дванадцять ';
    dig(13) := 'тринадцять ';
    dig(14) := 'чотирнадцять ';
    dig(15) := 'п''ятнадцять ';
    dig(16) := 'шiстнадцять ';
    dig(17) := 'сiмнадцять ';
    dig(18) := 'вiсiмнадцять ';
    dig(19) := 'дев''ятнадцять ';

    Dig_a(0) := '';
    dig_a(1) := 'один ';
    dig_a(2) := 'два ';
    dig_a(3) := 'три ';
    dig_a(4) := 'чотири ';
    dig_a(5) := 'п''ять ';
    dig_a(6) := 'шiсть ';
    dig_a(7) := 'сiм ';
    dig_a(8) := 'вiсiм ';
    dig_a(9) := 'дев''ять ';
    dig_a(10) := 'десять ';
    dig_a(11) := 'одинадцять ';
    dig_a(12) := 'дванадцять ';
    dig_a(13) := 'тринадцять ';
    dig_a(14) := 'чотирнадцять ';
    dig_a(15) := 'п''ятнадцять ';
    dig_a(16) := 'шiстнадцять ';
    dig_a(17) := 'сiмнадцять ';
    dig_a(18) := 'вiсiмнадцять ';
    dig_a(19) := 'дев''ятнадцять ';

    ten(0) := '';
    ten(1) := '';
    ten(2) := 'двадцять ';
    ten(3) := 'тридцять ';
    ten(4) := 'сорок ';
    ten(5) := 'п''ятдесят ';
    ten(6) := 'шiстдесят ';
    ten(7) := 'сiмдесят ';
    ten(8) := 'вiсiмдесят ';
    ten(9) := 'дев''яносто ';

    Hun(0) := '';
    Hun(1) := 'сто ';
    Hun(2) := 'двiстi ';
    Hun(3) := 'триста ';
    Hun(4) := 'чотириста ';
    Hun(5) := 'п''ятсот ';
    Hun(6) := 'шiстсот ';
    Hun(7) := 'сiмсот ';
    Hun(8) := 'вiсiмсот ';
    Hun(9) := 'дев''ятсот ';

    if Currvalue = 0
    then
      p_result := 'Нуль ';
    else
      while CurrValue > 0
      loop
        if (CurrValue mod 1000) <> 0 
        then
          S := CurrValue mod 100;
          if S < 20
          then
            if i <= 1 
            then
              if p_curr_code = 'UAH' 
              then
                DIGIT := dig_a(s);
              else
                DIGIT := dig(s);
              end if;
            else
              DIGIT := dig(s);
            end if;

            if i = 0 then
              RADIX := '';
            elsif i = 1 then
              RADIX := tis(s);
            elsif i = 2 then
              RADIX := mln(s);
            elsif i = 3 then
              RADIX := mlrd(s);
            end if;

            p_result := DIGIT || RADIX || p_result;
          else

            if i <= 1 then
              DIGIT := dig_a(mod(s, 10));
            else
              DIGIT := dig(mod(s, 10));
            end if;

            if i = 0 then
              RADIX := '';
            elsif i = 1 then
              RADIX := tis(mod(s, 10));
            elsif i = 2 then
              begin
                if mod(s, 10) = 0 then
                  RADIX := mln(5);
                else
                  RADIX := mln(mod(s, 10));
                end if;
              end;
            elsif i = 3 then
              begin
                if mod(s, 10) = 0 then
                  RADIX := mlrd(5);
                else
                  RADIX := mlrd(mod(s, 10));
                end if;
              end;
            end if;

            p_result := Ten(trunc(S / 10)) || DIGIT || RADIX || p_result;

          end if;
          CurrValue := trunc(CurrValue / 100);
          S         := CurrValue mod 10;
          p_result    := Hun(S) || p_result;
          CurrValue := trunc(CurrValue / 10);
          i         := i + 1;
        else
          CurrValue := trunc(CurrValue / 1000);
          i         := i + 1;
        end if;
      end loop;
    end if;

    if p_is_decimal = 'T' then
      p_result := p_result || ' цiлих ' || to_char(fraction, '00') || ' сотих';
    else
      if (upper(p_curr_code) = 'UAH') or (trim(both p_curr_code) is null) then
        CResult := OriginVal::varchar;
        l       := length(CResult);
        if ((l > 1) and ((substr(CResult, l - 1, 2))::numeric  > 10) and ((substr(CResult, l - 1, 2))::numeric  < 20)) then
          p_result := p_result || ' гривень';
        elsif (substr(CResult, l, 1))::numeric  = 0 then
          p_result := p_result || ' гривень';
        elsif (substr(CResult, l, 1))::numeric  = 1 then
          p_result := p_result || ' гривня';
        elsif ((substr(CResult, l, 1))::numeric  = 2) or ((substr(CResult, l, 1))::numeric  = 3) or ((substr(CResult, l, 1))::numeric  = 4) then
          p_result := p_result || ' гривні';
        else
          p_result := p_result || ' гривень';
        end if;
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' копійка';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' копійки';
        else
          p_result := p_result || to_char(fraction, '00') || ' копійок';
        end if;
  ------------------------------------------------------------------
      elsif (upper(p_curr_code) = 'USD') then
        CResult := OriginVal::varchar;
        l       := length(CResult);
        if ((l > 1) and ((substr(CResult, l - 1, 2))::numeric  > 10) and ((substr(CResult, l - 1, 2))::numeric  < 20)) then
          p_result := p_result || ' доларiв США';
        elsif (substr(CResult, l, 1))::numeric  = 0 then
          p_result := p_result || ' доларiв США';
        elsif (substr(CResult, l, 1))::numeric  = 1 then
          p_result := p_result || ' долар США';
        elsif ((substr(CResult, l, 1))::numeric  = 2) or ((substr(CResult, l, 1))::numeric  = 3) or ((substr(CResult, l, 1))::numeric  = 4) then
          p_result := p_result || ' долари США';
        else
          p_result := p_result || ' доларiв США';
        end if;
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' цент';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' центи';
        else
          p_result := p_result || to_char(fraction, '00') || ' центiв';
        end if;
  ------------------------------------------------------------------
        elsif (upper(p_curr_code) = 'EUR') then
          p_result := p_result || ' євро ';
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' євроцент';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' євроценти';
        else
          p_result := p_result || to_char(fraction, '00') || ' євроцентiв';
        end if;
  ------------------------------------------------------------------
        elsif (upper(p_curr_code) = 'GBP') then
          CResult := OriginVal::varchar;
          l       := length(CResult);
        if ((l > 1) and ((substr(CResult, l - 1, 2))::numeric  > 10) and ((substr(CResult, l - 1, 2))::numeric  < 20)) then
          p_result := p_result || ' англійських Фунтів стерлінгів';
        elsif (substr(CResult, l, 1))::numeric  = 0 then
          p_result := p_result || ' англійських Фунтів стерлінгів';
        elsif (substr(CResult, l, 1))::numeric  = 1 then
          p_result := p_result || ' англійських Фунт стерлінгів';
        elsif ((substr(CResult, l, 1))::numeric  = 2) or ((substr(CResult, l, 1))::numeric  = 3) or ((substr(CResult, l, 1))::numeric  = 4) then
          p_result := p_result || ' англійських Фунти стерлінгів';
        else
          p_result := p_result || ' англійських Фунтів стерлінгів';
        end if;
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' пенс';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' пенси';
        else
          p_result := p_result || to_char(fraction, '00') || ' пенсiв';
        end if;
  ------------------------------------------------------------------
        elsif (upper(p_curr_code) = 'CHF') then
          CResult := OriginVal::varchar;
          l       := length(CResult);
        if ((l > 1) and ((substr(CResult, l - 1, 2))::numeric  > 10) and ((substr(CResult, l - 1, 2))::numeric  < 20)) then
          p_result := p_result || ' швейцарських франків';
        elsif (substr(CResult, l, 1))::numeric  = 0 then
          p_result := p_result || ' швейцарських франків';
        elsif (substr(CResult, l, 1))::numeric  = 1 then
          p_result := p_result || ' швейцарський франк';
        elsif ((substr(CResult, l, 1))::numeric  = 2) or ((substr(CResult, l, 1))::numeric  = 3) or ((substr(CResult, l, 1))::numeric  = 4) then
          p_result := p_result || ' швейцарських франки';
        else
          p_result := p_result || ' швейцарських франків';
        end if;
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' сантим';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' сантими';
        else
          p_result := p_result || to_char(fraction, '00') || ' сантимiв';
        end if;
  ------------------------------------------------------------------
        elsif (upper(p_curr_code) = 'RUR') then
          CResult := OriginVal::varchar;
          l       := length(CResult);
        if ((l > 1) and ((substr(CResult, l - 1, 2))::numeric  > 10) and ((substr(CResult, l - 1, 2))::numeric  < 20)) then
          p_result := p_result || 'російських рублів';
        elsif (substr(CResult, l, 1))::numeric  = 0 then
          p_result := p_result || 'російських рублів';
        elsif (substr(CResult, l, 1))::numeric  = 1 then
          p_result := p_result || 'російський рубель';
        elsif ((substr(CResult, l, 1))::numeric  = 2) or ((substr(CResult, l, 1))::numeric  = 3) or ((substr(CResult, l, 1))::numeric  = 4) then
          p_result := p_result || 'російських рубля';
        else
          p_result := p_result || 'російських рублів';
        end if;
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' копійка';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' копійки';
        else
          p_result := p_result || to_char(fraction, '00') || ' копійок';
        end if;
  ------------------------------------------------------------------
        elsif (upper(p_curr_code) = 'RUB') then
          CResult := OriginVal::varchar;
          l       := length(CResult);
        if ((l > 1) and ((substr(CResult, l - 1, 2))::numeric  > 10) and ((substr(CResult, l - 1, 2))::numeric  < 20)) then
          p_result := p_result || 'російських рублів';
        elsif (substr(CResult, l, 1))::numeric  = 0 then
          p_result := p_result || 'російських рублів';
        elsif (substr(CResult, l, 1))::numeric  = 1 then
          p_result := p_result || 'російський рубель';
        elsif ((substr(CResult, l, 1))::numeric  = 2) or ((substr(CResult, l, 1))::numeric  = 3) or ((substr(CResult, l, 1))::numeric  = 4) then
          p_result := p_result || 'російських рубля';
        else
          p_result := p_result || 'російських рублів';
        end if;
  ------------------------------------------------------------------
        if substr(fraction,1,2) in (01,21,31,41,51,61,71,81,91) then
          p_result := p_result || to_char(fraction, '00') || ' копійка';
        elsif substr(fraction,1,2) in (02,03,04,22,23,24,32,33,34,
                                       42,43,44,52,53,54,62,63,64,
                                       72,73,74,82,83,84,92,93,94) then
          p_result := p_result || to_char(fraction, '00') || ' копійки';
        else
          p_result := p_result || to_char(fraction, '00') || ' копійок';
        end if;
  ------------------------------------------------------------------
        else
          p_result := p_result || ' ' || to_char(fraction, '00') || ' ' ||
                  p_curr_code;
        end if;
    end if;

    p_result := upper(substr(p_result, 1, 1)) || substr(p_result, 2, 254);
    p_result := replace(p_result, '  ', ' ');

    return(trim(both substr(p_result, 1, 255)));

  exception when others
  then
      return(p_result);
  end;

  -- Преобразование суммы в текст
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.str_amount_curr (p_amount numeric, p_curr_code text default 'UAH', p_is_decimal char default 'F') FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.str_amount (p_amount numeric, p_is_default char DEFAULT 'T') RETURNS varchar AS $body$
DECLARE

    type WordType is table of varchar(30) index by integer;
    dig       WordType;
    dig_a     WordType;
    ten       WordType;
    hun       WordType;
    tis       WordType;
    mln       WordType;
    mlrd      WordType;
    i         numeric := 0;
    CurrValue numeric;
    S         numeric;
    p_result  varchar(255);
    DIGIT     varchar(255);
    RADIX     varchar(255);

BEGIN
    CurrValue := trunc(p_amount);
    -- тысячи
    tis(0) := 'тисяч ';
    tis(1) := 'тисяча ';
    tis(2) := 'тисячi ';
    tis(3) := 'тисячi ';
    tis(4) := 'тисячi ';
    tis(5) := 'тисяч ';
    tis(6) := 'тисяч ';
    tis(7) := 'тисяч ';
    tis(8) := 'тисяч ';
    tis(9) := 'тисяч ';
    tis(10) := 'тисяч ';
    tis(11) := 'тисяч ';
    tis(12) := 'тисяч ';
    tis(13) := 'тисяч ';
    tis(14) := 'тисяч ';
    tis(15) := 'тисяч ';
    tis(16) := 'тисяч ';
    tis(17) := 'тисяч ';
    tis(18) := 'тисяч ';
    tis(19) := 'тисяч ';
    -- мiльйон
    mln(0) := 'мiльйонiв ';
    mln(1) := 'мiльйон ';
    mln(2) := 'мiльйона ';
    mln(3) := 'мiльйона ';
    mln(4) := 'мiльйона ';
    mln(5) := 'мiльйонiв ';
    mln(6) := 'мiльйонiв ';
    mln(7) := 'мiльйонiв ';
    mln(8) := 'мiльйонiв ';
    mln(9) := 'мiльйонiв ';
    mln(10) := 'мiльйонiв ';
    mln(11) := 'мiльйонiв ';
    mln(12) := 'мiльйонiв ';
    mln(13) := 'мiльйонiв ';
    mln(14) := 'мiльйонiв ';
    mln(15) := 'мiльйонiв ';
    mln(16) := 'мiльйонiв ';
    mln(17) := 'мiльйонiв ';
    mln(18) := 'мiльйонiв ';
    mln(19) := 'мiльйонiв ';
    -- мiльярдiв
    mlrd(0) := ' ';
    mlrd(1) := 'мiльярд ';
    mlrd(2) := 'мiльярда ';
    mlrd(3) := 'мiльярда ';
    mlrd(4) := 'мiльярда ';
    mlrd(5) := 'мiльярдiв ';
    mlrd(6) := 'мiльярдiв ';
    mlrd(7) := 'мiльярдiв ';
    mlrd(8) := 'мiльярдiв ';
    mlrd(9) := 'мiльярдiв ';
    mlrd(10) := 'мiльярдiв ';
    mlrd(11) := 'мiльярдiв ';
    mlrd(12) := 'мiльярдiв ';
    mlrd(13) := 'мiльярдiв ';
    mlrd(14) := 'мiльярдiв ';
    mlrd(15) := 'мiльярдiв ';
    mlrd(16) := 'мiльярдiв ';
    mlrd(17) := 'мiльярдiв ';
    mlrd(18) := 'мiльярдiв ';
    mlrd(19) := 'мiльярдiв ';

    Dig(0) := '';
    dig(1) := 'один ';
    dig(2) := 'два ';
    dig(3) := 'три ';
    dig(4) := 'чотири ';
    dig(5) := 'п''ять ';
    dig(6) := 'шiсть ';
    dig(7) := 'сiм ';
    dig(8) := 'вiсiм ';
    dig(9) := 'дев''ять ';
    dig(10) := 'десять ';
    dig(11) := 'одинадцять ';
    dig(12) := 'дванадцять ';
    dig(13) := 'тринадцять ';
    dig(14) := 'чотирнадцять ';
    dig(15) := 'п''ятнадцять ';
    dig(16) := 'шiстнадцять ';
    dig(17) := 'сiмнадцять ';
    dig(18) := 'вiсiмнадцять ';
    dig(19) := 'дев''ятнадцять ';

    Dig_a(0) := '';
    dig_a(1) := 'одна ';
    dig_a(2) := 'двi ';
    dig_a(3) := 'три ';
    dig_a(4) := 'чотири ';
    dig_a(5) := 'п''ять ';
    dig_a(6) := 'шiсть ';
    dig_a(7) := 'сiм ';
    dig_a(8) := 'вiсiм ';
    dig_a(9) := 'дев''ять ';
    dig_a(10) := 'десять ';
    dig_a(11) := 'одинадцять ';
    dig_a(12) := 'дванадцять ';
    dig_a(13) := 'тринадцять ';
    dig_a(14) := 'чотирнадцять ';
    dig_a(15) := 'п''ятнадцять ';
    dig_a(16) := 'шiстнадцять ';
    dig_a(17) := 'сiмнадцять ';
    dig_a(18) := 'вiсiмнадцять ';
    dig_a(19) := 'дев''ятнадцять ';

    ten(0) := '';
    ten(1) := '';
    ten(2) := 'двадцять ';
    ten(3) := 'тридцять ';
    ten(4) := 'сорок ';
    ten(5) := 'п''ятдесят ';
    ten(6) := 'шiстдесят ';
    ten(7) := 'сiмдесят ';
    ten(8) := 'вiсiмдесят ';
    ten(9) := 'дев''яносто ';

    Hun(0) := '';
    Hun(1) := 'сто ';
    Hun(2) := 'двiстi ';
    Hun(3) := 'триста ';
    Hun(4) := 'чотириста ';
    Hun(5) := 'п''ятсот ';
    Hun(6) := 'шiстсот ';
    Hun(7) := 'сiмсот ';
    Hun(8) := 'вiсiмсот ';
    Hun(9) := 'дев''ятсот ';

    if Currvalue = 0
    then
      p_result := 'Нуль ';
    else
      while CurrValue > 0
      loop
        if (CurrValue mod 1000) <> 0 
        then 
          S := CurrValue mod 100;
          if S < 20 then

            if i <= 1 then
              if p_is_default = 'T' then
                DIGIT := dig_a(s);
              else
                if i = 1 then
                  DIGIT := dig_a(s);
                else
                  DIGIT := dig(s);
                end if;
              end if;
            else
              DIGIT := dig(s);
            end if;

            if i = 0 then
              RADIX := '';
            elsif i = 1 then
              RADIX := tis(s);
            elsif i = 2 then
              RADIX := mln(s);
            elsif i = 3 then
              RADIX := mlrd(s);
            end if;

            p_result := DIGIT||RADIX|| p_result;
          else

            if i <= 1 then
              if p_is_default = 'T' then
                DIGIT := dig_a(mod(s, 10));
              else
                DIGIT := dig(mod(s, 10));
              end if;
            else
              DIGIT := dig(mod(s, 10));
            end if;

            if i = 0 then
              RADIX := '';
            elsif i = 1 then
              RADIX := tis(mod(s, 10));
            elsif i = 2 then
              begin
              if mod(s, 10) = 0 then
                 RADIX := mln(5);
              else
                 RADIX := mln(mod(s, 10));
              end if;
              end;
            elsif i = 3 then
              begin
              if mod(s, 10) = 0 then
                 RADIX := mlrd(5);
              else
                 RADIX := mlrd(mod(s, 10));
              end if;
              end;
            end if;

            p_result := Ten(trunc(S/10))||DIGIT||RADIX||p_result;

          end if;
          CurrValue := trunc(CurrValue/100);
          S := CurrValue mod 10;
          p_result := Hun(S) ||p_result;
          CurrValue := trunc(CurrValue/10);
          i := i + 1;
        else
          CurrValue := trunc(CurrValue/1000);
          i := i + 1;
        end if;
      end loop;
    end if;

    p_result := upper(substr(p_result, 1, 1))||substr(p_result, 2, 254);
    return(trim(both substr(p_result, 1, 255)));

  exception when others
  then 
    return(p_result);
  end;

  -- Преобразование суммы в текстовый формат числа
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.str_amount (p_amount numeric, p_is_default char DEFAULT 'T') FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.str_amount_format (p_number numeric, p_count_comma integer default 2) RETURNS varchar AS $body$
DECLARE

    p_n varchar(255);
    pos integer;
    p_num numeric;

BEGIN
    if p_number is null then return p_number; end if;
    p_num := p_number;
    if p_num > 999999999999 then p_num := 999999999999; end if;

    if p_count_comma = 0 then p_n := to_char(p_num,'999G999G999G990'); end if;
    if p_count_comma = 1 then p_n := to_char(p_num,'999G999G999G990D0'); end if;
    if p_count_comma = 2 then p_n := to_char(p_num,'999G999G999G990D00'); end if;
    if p_count_comma = 3 then p_n := to_char(p_num,'999G999G999G990D000'); end if;
    if p_count_comma = 4 then p_n := to_char(p_num,'999G999G999G990D0000'); end if;
    if p_count_comma = 5 then p_n := to_char(p_num,'999G999G999G990D00000'); end if;
    if p_count_comma > 5 or p_count_comma is null
    then
       RAISE EXCEPTION '%', 'Количество знаков после запятой не может быль больше 5 или NULL !!!' USING ERRCODE = '45000';
    end if;

    p_n := replace(p_n,'.',chr(44));
    p_n := replace(p_n,chr(44),' ');
    p_n := trim(both p_n);

    -- восстанавливаем последнюю запятую
    pos := instr(p_n,' ',-1,1);
    if p_count_comma = 0 then p_n := p_n; end if;
    if p_count_comma <> 0 then p_n := substr(p_n,1,pos-1) || chr(44) || substr(p_n,pos+1,length(p_n)-pos); end if;

    return p_n;
  end;

  -- Преобразование процента с тест (0,5678999% (нуль цiлих i п'ять мiльйонiв шiстсот сiмдесят вiсiм тисяч дев'ятсот дев'яносто дев'ять десятимільйонних процента))
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.str_amount_format (p_number numeric, p_count_comma integer default 2) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.str_interest (p_amount numeric) RETURNS varchar AS $body$
DECLARE

    p_result      varchar(255);
    Fraction      numeric;
    FractionType  varchar(255);
    FractionT     varchar(255);
    FractionFM    varchar(255);
    p_last_amount numeric;

BEGIN
    Fraction := p_amount - Trunc(p_amount);
    FractionT := substr(p_convert.num_to_str(Fraction),3);
    FractionFM := 'FM999,999,999,990.00';
    if    length(FractionT) = 1 then
             FractionType := 'десятих';
             Fraction := Fraction * 10;
    elsif length(FractionT) = 2 then 
             FractionType := 'сотих';
             Fraction := Fraction * 100;
    elsif length(FractionT) = 3 then
             FractionType := 'тисячних';
             Fraction := Fraction * 1000;
             FractionFM := 'FM999,999,999,990.000';
    elsif length(FractionT) = 4 then 
             FractionType := 'десятитисячних';
             Fraction := Fraction * 10000;
             FractionFM := 'FM999,999,999,990.0000';
    elsif length(FractionT) = 5 then 
             FractionType := 'стотисячних';
             Fraction := Fraction * 100000;
             FractionFM := 'FM999,999,999,990.00000';
    elsif length(FractionT) = 6 then 
             FractionType := 'мільйонних';
             Fraction := Fraction * 1000000;
             FractionFM := 'FM999,999,999,990.000000';
    elsif length(FractionT) = 7 then 
             FractionType := 'десятимільйонних';
             Fraction := Fraction * 10000000;
             FractionFM := 'FM999,999,999,990.0000000';
    elsif length(FractionT) = 8 then 
             FractionType := 'стомільйонних';
             Fraction := Fraction * 100000000;
             FractionFM := 'FM999,999,999,990.00000000';
    elsif length(FractionT) > 8 
      then 
         return null;
    end if;

    if Fraction = 0
    then
      p_result := trim(both to_char(p_amount, FractionFM))||'% ('||p_convert.str_amount(p_amount, 'F');

      -- добавляем
      p_last_amount := (substr(p_amount::varchar, -1, 1))::numeric;
      if (p_last_amount in (0,5,6,7,8,9) or p_amount in (11,12,13,14,15,16,17,18,19)) then p_result := p_result||' процентiв)';
      elsif p_last_amount = 1 then p_result := p_result||' процент)';
      elsif p_last_amount in (2,3,4) then p_result := p_result||' процента)';
      else
         p_result := p_result||' процента)';
      end if;

    else
      p_result := trim(both to_char(p_amount, FractionFM))||'% ('||p_convert.str_amount(p_amount);

      if trunc(p_amount) = 1
      then
         p_result := p_result||' цiла i '||lower(p_convert.str_amount(Fraction))||' '||FractionType;
      else
         p_result := p_result||' цiлих i '||lower(p_convert.str_amount(Fraction))||' '||FractionType;
      end if;

      p_result := p_result||' процента)';
    end if;

    p_result := lower(p_result);

    -- замена
    if FractionType is not null and substr(p_convert.num_to_str(p_amount),-1) = '1'
        and substr(p_convert.num_to_str(p_amount),-2) != '11'
    then
        if    length(FractionT) = 1 then p_result := replace(p_result, 'десятих', 'десята');
        elsif length(FractionT) = 2 then p_result := replace(p_result, 'сотих', 'сота');
        elsif length(FractionT) = 3 then p_result := replace(p_result, 'тисячних', 'тисячна');
        elsif length(FractionT) = 4 then p_result := replace(p_result, 'десятитисячних', 'десятитисячна');
        elsif length(FractionT) = 5 then p_result := replace(p_result, 'стотисячних', 'стотисячна');
        elsif length(FractionT) = 6 then p_result := replace(p_result, 'мільйонних', 'мільйонна');
        elsif length(FractionT) = 7 then p_result := replace(p_result, 'десятимільйонних', 'десятимільйонна');
        elsif length(FractionT) = 8 then p_result := replace(p_result, 'стомільйонних', 'стомільйонна');
        end if;
    end if;

    return replace((trim(both substr(p_result, 1, 255))), '.', ',');

  exception when others
  then      
    return p_result;
  end;

  -- Преобразование теста с UTF8 в базовую кодировку Oracle (до 4000 символов)
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.str_interest (p_amount numeric) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.get_charset_utf8 (p_text text) RETURNS varchar AS $body$
BEGIN
    if p_text in ('null', 'nul') then return null; end if;
    -- В кодировку базы (максимум: 4000 или ошибка ORA-22835)
    return UTL_I18N.raw_to_char(UTL_I18N.STRING_TO_RAW(p_text, current_setting('p_convert.m_base_charset')::varchar(50)), 'UTF8');
  exception when others then
      return p_text;
  end;

  -- Преобразование теста с базовую кодировки Oracle в UTF8 (до 4000 символов)
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.get_charset_utf8 (p_text text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.to_charset_utf8 (p_text text) RETURNS varchar AS $body$
BEGIN
    -- В кодировку базы (максимум: 4000 или ошибка ORA-22835)
    return UTL_I18N.raw_to_char(UTL_I18N.STRING_TO_RAW(p_text, 'UTF8'), current_setting('p_convert.m_base_charset')::varchar(50));
  exception when others then
      return p_text;
  end;

   -- Экранирование символов для JSON с доп. конвертацией в UTF8
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.to_charset_utf8 (p_text text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.screening_json (p_str text, p_is_convert_utf8 text default 'F') RETURNS varchar AS $body$
DECLARE

    p_result varchar(32767);

BEGIN
    if p_is_convert_utf8 = 'T'
    then
       p_result := p_convert.to_charset_utf8(p_str);
    else
       p_result := p_str;
    end if;

    -- для JSON экранируем служебные символы
    p_result := replace(p_result,'\','\\');
    p_result := replace(p_result,'"','\"');
    p_result := replace(p_result,'/','\/');
    return p_result;
  end;

  -- Преобразование теста с число
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.screening_json (p_str text, p_is_convert_utf8 text default 'F') FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.str_to_num (p_text text) RETURNS numeric AS $body$
DECLARE

    m_text varchar(32000);

BEGIN
    m_text := replace(p_text,',','.');
    return(to_number(trim(both m_text), '999999999999999999999999999999.99999999999999999999999999999'));
  exception when others
  then
     RAISE EXCEPTION '%', 'Невозможно преобразовать в число ='||p_text USING ERRCODE = '45000';
  end;

  -- Преобразование теста в дату
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.str_to_num (p_text text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.str_to_date (p_text text) RETURNS timestamp AS $body$
BEGIN
    return(to_date(trim(both p_text), 'dd.mm.yyyy'));
  exception when others
  then
     RAISE EXCEPTION '%', 'Невозможно преобразовать в дату ='||p_text USING ERRCODE = '45000';
  end;

  -- Преобразование числа в тест
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.str_to_date (p_text text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.num_to_str (p_amount numeric) RETURNS varchar AS $body$
DECLARE

     m_result   varchar(60);
     m_len      integer;

BEGIN
     if p_amount is null then return ''; end if;

     m_result := trim(both to_char(p_amount, '999999999999999999999999999999.99999999999999999999999999999'));
     m_len    := length(m_result);

     for i in 0..m_len
     loop
       if substr(m_result, m_len - i, 1) != '0'
       then
         exit;
       else
         m_result := substr(m_result, 1, m_len - (i + 1));
       end if;
     end loop;

     m_result := trim(both m_result);
     m_len    := length(m_result);

     if substr(m_result, m_len, 1) in ('.', ',')
     then
       m_result := substr(m_result, 1, m_len - 1);
     end if;

     m_result := trim(both m_result);

     if substr(m_result, 1, 1) in ('.', ',')
     then
       m_result := '0'||m_result;
     end if;

     return m_result;
  end;

  -- Преобразование теста из одной в другую кодировку
  -- 'UTF8','CL8MSWIN1251'
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.num_to_str (p_amount numeric) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.convert_str (p_text text, p_char_set_to text, -- преобразовать в
 p_char_set_from text default null -- преобразования из
) RETURNS varchar AS $body$
BEGIN
      if p_char_set_from is null
      then  
         return convert(p_text, p_char_set_to);
      else
         return convert(p_text, p_char_set_to, p_char_set_from);
      end if;
  end;
  
  -- Прообразование теста в дату и время (формат YYYY-MM-DDThh24:mi:ssZ)
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.convert_str (p_text text, p_char_set_to text, p_char_set_from text default null ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_convert.get_datetime (p_text text) RETURNS timestamp AS $body$
DECLARE

    m_date timestamp;

BEGIN
     if p_text in ('null', 'nul') then return null; end if;

     if length(p_text) > 20
     then
         select max(cast(TO_TIMESTAMP(p_text, 'YYYY-MM-DD"T"hh24:mi:ss.FF9"Z"') AS timestamp)) into STRICT m_date
;
     elsif length(p_text) = 20
     then
         select max(cast(TO_TIMESTAMP(p_text, 'YYYY-MM-DD"T"hh24:mi:ss"Z"') AS timestamp)) into STRICT m_date
;
     elsif length(p_text) = 17
     then
         select max(cast(TO_TIMESTAMP(p_text, 'YYYY-MM-DD"T"hh24:mi"Z"') AS timestamp)) into STRICT m_date
;
     end if;

     return m_date;
  exception
     when self_is_null then
        return to_date(null);
  end;


$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_convert.get_datetime (p_text text) FROM PUBLIC;
-- End of Oracle package 'P_CONVERT' declaration



-- Oracle package 'P_INTERFACE' declaration, please edit to match PostgreSQL syntax.

DROP SCHEMA IF EXISTS p_interface CASCADE;
CREATE SCHEMA IF NOT EXISTS p_interface;



-- Справедливая стоимость ЦБ (котировки НБУ)
    -- Получить данные
    -- select f.* from table (p_interface.read_fair_value(p_date => to_date('09.04.2021','dd.mm.yyyy'))) f;    
CREATE OR REPLACE FUNCTION p_interface.read_fair_value (p_date timestamp -- дата
) RETURNS T_FAIR_VALUE_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_num                  numeric := 1;
      ---------------------------------------
      p_fair_value_row       t_fair_value_row   := t_fair_value_row('','','','','','','','','','','','','','','','','');
      p_fair_value_table     t_fair_value_table := t_fair_value_table();

  j RECORD;
  k RECORD;

BEGIN
      p_url := 'https://bank.gov.ua/files/Fair_value/'||to_char(p_date,'yyyymm/yyyymmdd')||'_fv.txt';

      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'GET',
                   p_header_body_charset => 'WINDOWS-1251',
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
      --dbms_output.put_line(p_response_body);
      
      for j in (WITH RECURSIVE cte AS (

                with tt as (SELECT p_response_body || chr(13)||chr(10) as str )
                PERFORM (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^'||chr(13)||chr(10)||']+', 'g') AS foo(a) LIMIT 1 OFFSET (level - 1)) as string_row, row_number() OVER () as num
                from tt
                coalesce(regexp_instr(str, '[^'||chr(13)||chr(10)||']+', 1, level), 0) <> 0
                  UNION ALL

                with tt as (SELECT p_response_body || chr(13)||chr(10) as str )
                PERFORM (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^'||chr(13)||chr(10)||']+', 'g') AS foo(a) LIMIT 1 OFFSET (level - 1)) as string_row, row_number() OVER () as num
                from tt
                coalesce(regexp_instr(str, '[^'||chr(13)||chr(10)||']+', 1, level), 0) <> 0
                 JOIN cte c ON ()

) SELECT * FROM cte;
)
      loop    
          -- заголовок пропускаем
          if j.num = 1 then continue; end if;

          for k in (
                    with tt as (SELECT j.string_row || ';' as str )
                    PERFORM p_convert.str_to_date((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (1 - 1))) as calc_date,
                           (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (2 - 1)) as cpcode,
                           (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (3 - 1)) as ccy,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (4 - 1))) as fair_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (5 - 1))) as ytm,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (6 - 1))) as clean_rate,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (7 - 1))) as cor_coef,
                           p_convert.str_to_date((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (8 - 1))) as maturity,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (9 - 1))) as cor_coef_cash,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (10 - 1))) as notional,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (11 - 1))) as avr_rate,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (12 - 1))) as option_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (13 - 1))) as intrinsic_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (14 - 1))) as time_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (15 - 1))) as delta_per,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (16 - 1))) as delta_equ,
                           (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (17 - 1)) as dop
                    from tt
                    )
           loop
              p_fair_value_row.calc_date := k.calc_date;
              p_fair_value_row.cpcode := k.cpcode;
              p_fair_value_row.ccy := k.ccy;
              p_fair_value_row.fair_value := k.fair_value;
              p_fair_value_row.ytm := k.ytm;
              p_fair_value_row.clean_rate := k.clean_rate;
              p_fair_value_row.cor_coef := k.cor_coef;
              p_fair_value_row.maturity := k.maturity;
              p_fair_value_row.cor_coef_cash := k.cor_coef_cash;
              p_fair_value_row.notional := k.notional;
              p_fair_value_row.avr_rate := k.avr_rate;
              p_fair_value_row.option_value := k.option_value;
              p_fair_value_row.intrinsic_value := k.intrinsic_value;
              p_fair_value_row.time_value := k.time_value;
              p_fair_value_row.delta_per := k.delta_per;
              p_fair_value_row.delta_equ := k.delta_equ;
              p_fair_value_row.dop := k.dop;
              --
              p_fair_value_table.extend;
              p_fair_value_table(p_num) := p_fair_value_row;
              p_num := p_num + 1;
           end loop;
       end loop;

       return p_fair_value_table;
    end;

    -- Перечень ISIN ЦБ с купонными периодами
    -- Получить данные
    -- select f.* from table (p_interface.read_isin_secur(p_format => 'json')) f;        
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION p_interface.read_fair_value (p_date timestamp ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_interface.read_isin_secur (p_format text -- формат xml, json
) RETURNS T_ISIN_SECUR_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_dop_param            varchar(5);
      p_num                  numeric := 1;
      ---------------------------------------
      p_isin_secur_row       t_isin_secur_row   := t_isin_secur_row('','','','','','','','','','','','','','','','','','');
      p_isin_secur_table     t_isin_secur_table := t_isin_secur_table();

  k RECORD;
  kk RECORD;

BEGIN
      if p_format = 'json' then p_dop_param := '?json'; end if;
      p_url := 'https://bank.gov.ua/depo_securities'||p_dop_param;

      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'GET',
                   p_header_content_type => case when p_format = 'json' then 'application/json' else 'text/xml' end,
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
       --dbms_output.put_line(p_response_body);
       
       if p_format = 'json'            
       then
          if p_check.is_valid_json(p_response_body) = 'T'
          then  
              for k in (
                       SELECT t.cpcode,
                              t.nominal,                                      
                              p_convert.str_to_num(t.auk_proc) as auk_proc,
                              p_convert.str_to_date(t.pgs_date) as pgs_date,
                              p_convert.str_to_date(t.razm_date) as razm_date,
                              t.cptype,
                              t.cpdescr,
                              t.pay_period,                                      
                              t.val_code,                                      
                              t.emit_okpo,
                              t.emit_name,
                              t.cptype_nkcpfr,
                              t.cpcode_cfi,
                              t.total_bonds,
                              t.payments
                          from json_table(p_response_body, '$[*]'
                                           columns                 
                                              cpcode          varchar2(255) path '$.cpcode',
                                              nominal         integer       path '$.nominal',                                      
                                              auk_proc        varchar2(255) path '$.auk_proc',                                      
                                              pgs_date        varchar2(255) path '$.pgs_date',                                      
                                              razm_date       varchar2(255) path '$.razm_date',                                      
                                              cptype          varchar2(255) path '$.cptype',
                                              cpdescr         varchar2(255) path '$.cpdescr',
                                              pay_period      integer       path '$.pay_period',                                      
                                              val_code        varchar2(3)   path '$.val_code',                                      
                                              emit_okpo       varchar2(255) path '$.emit_okpo',
                                              emit_name       varchar2(255) path '$.emit_name',
                                              cptype_nkcpfr   varchar2(255) path '$.cptype_nkcpfr',
                                              cpcode_cfi      varchar2(255) path '$.cpcode_cfi',
                                              total_bonds     integer       path '$.pay_period',                                          
                                              payments        FORMAT JSON   path '$.payments'                                          
                                            ) t  
                         )
               loop             
                  if k.payments is null
                  then  
                      p_isin_secur_row.cpcode := k.cpcode;
                      p_isin_secur_row.nominal := k.nominal;
                      p_isin_secur_row.auk_proc := k.auk_proc;
                      p_isin_secur_row.pgs_date := k.pgs_date;
                      p_isin_secur_row.razm_date := k.razm_date;
                      p_isin_secur_row.cptype := k.cptype;
                      p_isin_secur_row.cpdescr := k.cpdescr;
                      p_isin_secur_row.pay_period := k.pay_period;
                      p_isin_secur_row.val_code := k.val_code;
                      p_isin_secur_row.emit_okpo := k.emit_okpo;
                      p_isin_secur_row.emit_name := k.emit_name;
                      p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                      p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                      p_isin_secur_row.total_bonds := k.total_bonds;
                      p_isin_secur_row.pay_date := null;
                      p_isin_secur_row.pay_type := null;
                      p_isin_secur_row.pay_val := null;
                      p_isin_secur_row.pay_array := null;
                      --
                      p_isin_secur_table.extend;
                      p_isin_secur_table(p_num) := p_isin_secur_row;
                      p_num := p_num + 1;
                  else
                      -- периоды
                      for kk in (
                                 SELECT p_convert.str_to_date(t.pay_date) as pay_date,
                                        t.pay_type,                                      
                                        p_convert.str_to_num(t.pay_val) as pay_val,
                                        t.pay_array
                                    from json_table(k.payments, '$[*]'
                                                     columns                 
                                                        pay_date        varchar2(255) path '$.pay_date',
                                                        pay_type        integer       path '$.pay_type',                                      
                                                        pay_val         varchar2(255) path '$.pay_val',                                      
                                                        pay_array       varchar2(255) path '$.array'
                                                      ) t  
                                )
                      loop          
                          p_isin_secur_row.cpcode := k.cpcode;
                          p_isin_secur_row.nominal := k.nominal;
                          p_isin_secur_row.auk_proc := k.auk_proc;
                          p_isin_secur_row.pgs_date := k.pgs_date;
                          p_isin_secur_row.razm_date := k.razm_date;
                          p_isin_secur_row.cptype := k.cptype;
                          p_isin_secur_row.cpdescr := k.cpdescr;
                          p_isin_secur_row.pay_period := k.pay_period;
                          p_isin_secur_row.val_code := k.val_code;
                          p_isin_secur_row.emit_okpo := k.emit_okpo;
                          p_isin_secur_row.emit_name := k.emit_name;
                          p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                          p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                          p_isin_secur_row.total_bonds := k.total_bonds;
                          p_isin_secur_row.pay_date := kk.pay_date;
                          p_isin_secur_row.pay_type := kk.pay_type;
                          p_isin_secur_row.pay_val := kk.pay_val;
                          p_isin_secur_row.pay_array := kk.pay_array;
                          --
                          p_isin_secur_table.extend;
                          p_isin_secur_table(p_num) := p_isin_secur_row;
                          p_num := p_num + 1;
                      end loop;
                   end if;
               end loop;
           end if;
       else
          if p_check.is_valid_xml(p_response_body) = 'T'
          then  
              for k in (
                       SELECT t.cpcode,
                              t.nominal,                                      
                              p_convert.str_to_num(t.auk_proc) as auk_proc,
                              p_convert.str_to_date(t.pgs_date) as pgs_date,
                              p_convert.str_to_date(t.razm_date) as razm_date,
                              t.cptype,
                              t.cpdescr,
                              t.pay_period,                                      
                              t.val_code,                                      
                              t.emit_okpo,
                              t.emit_name,
                              t.cptype_nkcpfr,
                              t.cpcode_cfi,
                              t.total_bonds,
                              t.payments
                          from xmltable('//security' passing xmltype(p_response_body)
                                           columns                 
                                              cpcode          varchar2(255) path 'cpcode',
                                              nominal         integer       path 'nominal',                                      
                                              auk_proc        varchar2(255) path 'auk_proc',                                      
                                              pgs_date        varchar2(255) path 'pgs_date',                                      
                                              razm_date       varchar2(255) path 'razm_date',                                      
                                              cptype          varchar2(255) path 'cptype',
                                              cpdescr         varchar2(255) path 'cpdescr',
                                              pay_period      integer       path 'pay_period',                                      
                                              val_code        varchar2(3)   path 'val_code',                                      
                                              emit_okpo       varchar2(255) path 'emit_okpo',
                                              emit_name       varchar2(255) path 'emit_name',
                                              cptype_nkcpfr   varchar2(255) path 'cptype_nkcpfr',
                                              cpcode_cfi      varchar2(255) path 'cpcode_cfi',
                                              total_bonds     integer       path 'pay_period',                                          
                                              payments        xmltype       path 'payments'
                                            ) t  
                         )
               loop             
                  if k.payments is null
                  then  
                      p_isin_secur_row.cpcode := k.cpcode;
                      p_isin_secur_row.nominal := k.nominal;
                      p_isin_secur_row.auk_proc := k.auk_proc;
                      p_isin_secur_row.pgs_date := k.pgs_date;
                      p_isin_secur_row.razm_date := k.razm_date;
                      p_isin_secur_row.cptype := k.cptype;
                      p_isin_secur_row.cpdescr := k.cpdescr;
                      p_isin_secur_row.pay_period := k.pay_period;
                      p_isin_secur_row.val_code := k.val_code;
                      p_isin_secur_row.emit_okpo := k.emit_okpo;
                      p_isin_secur_row.emit_name := k.emit_name;
                      p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                      p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                      p_isin_secur_row.total_bonds := k.total_bonds;
                      p_isin_secur_row.pay_date := null;
                      p_isin_secur_row.pay_type := null;
                      p_isin_secur_row.pay_val := null;
                      p_isin_secur_row.pay_array := null;
                      --
                      p_isin_secur_table.extend;
                      p_isin_secur_table(p_num) := p_isin_secur_row;
                      p_num := p_num + 1;
                  else
                      -- периоды
                      for kk in (
                                 SELECT p_convert.str_to_date(t.pay_date) as pay_date,
                                        t.pay_type,                                      
                                        p_convert.str_to_num(t.pay_val) as pay_val,
                                        t.pay_array
                                    from xmltable('//payment' passing k.payments
                                                     columns                 
                                                        pay_date        varchar2(255) path 'pay_date',
                                                        pay_type        integer       path 'pay_type',                                      
                                                        pay_val         varchar2(255) path 'pay_val',                                      
                                                        pay_array       varchar2(255) path 'array'
                                                      ) t  
                                )
                      loop          
                          p_isin_secur_row.cpcode := k.cpcode;
                          p_isin_secur_row.nominal := k.nominal;
                          p_isin_secur_row.auk_proc := k.auk_proc;
                          p_isin_secur_row.pgs_date := k.pgs_date;
                          p_isin_secur_row.razm_date := k.razm_date;
                          p_isin_secur_row.cptype := k.cptype;
                          p_isin_secur_row.cpdescr := k.cpdescr;
                          p_isin_secur_row.pay_period := k.pay_period;
                          p_isin_secur_row.val_code := k.val_code;
                          p_isin_secur_row.emit_okpo := k.emit_okpo;
                          p_isin_secur_row.emit_name := k.emit_name;
                          p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                          p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                          p_isin_secur_row.total_bonds := k.total_bonds;
                          p_isin_secur_row.pay_date := kk.pay_date;
                          p_isin_secur_row.pay_type := kk.pay_type;
                          p_isin_secur_row.pay_val := kk.pay_val;
                          p_isin_secur_row.pay_array := kk.pay_array;
                          --
                          p_isin_secur_table.extend;
                          p_isin_secur_table(p_num) := p_isin_secur_row;
                          p_num := p_num + 1;
                      end loop;
                   end if;
               end loop;
           end if;
       end if;

       return p_isin_secur_table;
    end;

    -- Курсы валют НБУ
    -- Получить данные
    -- select f.* from table (p_interface.read_kurs_nbu(p_date => to_date('09.04.2021','dd.mm.yyyy'), p_format => 'json', p_currency => 'USD')) f;
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_interface.read_isin_secur (p_format text ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_interface.read_kurs_nbu (p_date timestamp, -- дата курсов
 p_format text, -- формат xml, json
 p_currency text default null  -- UAH, USD, EUR
) RETURNS T_KURS_NBU_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_dop_param            varchar(5);
      p_num                  numeric := 1;
      ---------------------------------------
      p_kurs_nbu_row         t_kurs_nbu_row   := t_kurs_nbu_row(null,null,null,null,null);
      p_kurs_nbu_table       t_kurs_nbu_table := t_kurs_nbu_table();

  k RECORD;

BEGIN
      if p_format = 'json' then p_dop_param := '&json'; end if;

      if p_currency is null
      then  
         p_url := 'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?date='||to_char(p_date,'yyyymmdd')||p_dop_param;
      else
         p_url := 'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?valcode='||p_currency||'&date='||to_char(p_date,'yyyymmdd')||p_dop_param;
      end if;

      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'GET',
                   p_header_content_type => case when p_format = 'json' then 'application/json' else 'text/xml' end,
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
       --dbms_output.put_line(p_response_body);
       
       if p_format = 'json'            
       then
          if p_check.is_valid_json(p_response_body) = 'T'
          then  
              for k in (
                        SELECT lpad(j.r030,3,'0') as r030,
                               j.txt,
                               p_convert.str_to_num(j.rate) as rate,
                               j.cc,
                               p_convert.str_to_date(j.exchangedate) as exchangedate
                          from json_table(p_response_body, '$[*]' 
                                 columns(
                                         r030 varchar2(3)   path '$.r030',
                                         txt  varchar2(255) path '$.txt',
                                         rate varchar2(255) path '$.rate',                       
                                         cc   varchar2(255) path '$.cc',                       
                                         exchangedate varchar2(255) path '$.exchangedate'                       
                                         )) j
                         where j.r030 is not null and
                               j.txt  is not null and
                               j.rate is not null and
                               j.cc   is not null and
                               j.exchangedate is not null
                         )
               loop
                  p_kurs_nbu_row.r030 := k.r030;
                  p_kurs_nbu_row.txt := k.txt;
                  p_kurs_nbu_row.rate := k.rate;
                  p_kurs_nbu_row.cc := k.cc;
                  p_kurs_nbu_row.exchangedate := k.exchangedate;
                  --
                  p_kurs_nbu_table.extend;
                  p_kurs_nbu_table(p_num) := p_kurs_nbu_row;
                  p_num := p_num + 1;
               end loop;
           end if;
       else
          if p_check.is_valid_xml(p_response_body) = 'T'
          then  
              for k in (
                        SELECT lpad(j.r030,3,'0') as r030,
                               j.txt,
                               p_convert.str_to_num(j.rate) as rate,
                               j.cc,
                               p_convert.str_to_date(j.exchangedate) as exchangedate
                          from xmltable('//exchange/currency' passing xmltype(p_response_body)
                                 columns 
                                         r030 varchar2(3)   path 'r030',
                                         txt  varchar2(255) path 'txt',
                                         rate varchar2(255) path 'rate',                       
                                         cc   varchar2(255) path 'cc',                       
                                         exchangedate varchar2(255) path 'exchangedate'                       
                                         ) j
                         where j.r030 is not null and
                               j.txt  is not null and
                               j.rate is not null and
                               j.cc   is not null and
                               j.exchangedate is not null
                         )
               loop
                  p_kurs_nbu_row.r030 := k.r030;
                  p_kurs_nbu_row.txt := k.txt;
                  p_kurs_nbu_row.rate := k.rate;
                  p_kurs_nbu_row.cc := k.cc;
                  p_kurs_nbu_row.exchangedate := k.exchangedate;
                  --
                  p_kurs_nbu_table.extend;
                  p_kurs_nbu_table(p_num) := p_kurs_nbu_row;
                  p_num := p_num + 1;
               end loop;
           end if;
       end if;

       return p_kurs_nbu_table;
    end;

    -- НАИС - поиск контрагента в ЕРД (едином реестре должников)
    -- Получить данные
    -- select f.* from table (p_interface.read_erb_minfin(p_identCode => '33270581', p_type_cust_code => '2')) f;    
    -- select f.* from table (p_interface.read_erb_minfin(p_identCode => '2985108376', p_type_cust_code => '1')) f;
    -- select f.* from table (p_interface.read_erb_minfin(p_lastName       => 'Бондарчук',
    --                                                    p_firstName      => 'Ігор',
    --                                                    p_middleName     => 'Володимирович',
    --                                                    p_birthDate      => to_date('23.09.1981','dd.mm.yyyy'),
    --                                                    p_type_cust_code => '1')) f;
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_interface.read_kurs_nbu (p_date timestamp, p_format text, p_currency text default null  ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_interface.read_erb_minfin (p_categoryCode text default null, -- пусто все, 03 - аллименты
 p_identCode text default null, p_lastName text default null, p_firstName text default null, p_middleName text default null, p_birthDate timestamp default null, p_type_cust_code text -- (1 - физ., 2 - юр.)
  DEFAULT NULL) RETURNS T_ERB_MINFIN_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_request_body         text;
      p_num                  numeric := 1;
      ---------------------------------------
      p_erb_minfin_row       t_erb_minfin_row   := t_erb_minfin_row('','','','','','','','','','','','','','','','','','','','','');
      p_erb_minfin_table     t_erb_minfin_table := t_erb_minfin_table();

  k RECORD;

BEGIN
      p_url := 'https://erb.minjust.gov.ua/listDebtorsEndpoint';

      -- физ. лица
      if p_type_cust_code = '1'
      then  
          select JSON_OBJECT('searchType' value '1',
                             'paging'     value '1',
                             'filter'     value JSON_OBJECT('LastName'     value p_convert.screening_json(p_convert.convert_str(p_lastName,'UTF8','CL8MSWIN1251')),
                                                            'FirstName'    value p_convert.screening_json(p_convert.convert_str(p_firstName,'UTF8','CL8MSWIN1251')),
                                                            'MiddleName'   value p_convert.screening_json(p_convert.convert_str(p_middleName,'UTF8','CL8MSWIN1251')),
                                                            'BirthDate'    value case when p_birthDate is null then null
                                                                                      else to_char(p_birthDate,'YYYY-MM-DD')||'T00:00:00.000Z'
                                                                                 end,       
                                                            'IdentCode'    value p_identCode,
                                                            'categoryCode' value p_categoryCode
                                                            --absent on null -- если будет пустая переменная, тег не подставляется
                                                            null on null -- по умолчанию, если пустая передается null, можно не прописывать
                                                       )                   
                            )
                        into STRICT p_request_body                 
;
      else
      -- юр. лица        
          select JSON_OBJECT('searchType' value '2',
                             'filter'     value JSON_OBJECT('FirmName'     value p_convert.screening_json(p_convert.convert_str(p_lastName,'UTF8','CL8MSWIN1251')),
                                                            'FirmEdrpou'   value p_identCode,
                                                            'categoryCode' value p_categoryCode
                                                       )                   
                            )
                        into STRICT p_request_body                 
;
      end if;
      
      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'POST',
                   p_header_content_type => 'json',
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_header_body_charset => 'WINDOWS-1251',
                   p_request_body => p_request_body,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
       --dbms_output.put_line(p_request_body);      
       --dbms_output.put_line(p_response_body);
       --raise_application_error(-20000, p_request_body, true);           
       --raise_application_error(-20000, p_response_body, true);           
       
       if json_value(p_response_body,'$.errMsg') is not null
       then  
          RAISE EXCEPTION '%', p_request_body||chr(13)||chr(10)||json_value(p_response_body,'$.errMsg') USING ERRCODE = '45000';
       end if;

      if p_check.is_valid_json(p_response_body) = 'T'
      then   
          p_erb_minfin_row.isSuccess := json_value(p_response_body,'$.isSuccess');
          p_erb_minfin_row.num_rows := json_value(p_response_body,'$.rows');
          p_erb_minfin_row.requestDate := p_convert.get_datetime(json_value(p_response_body,'$.requestDate'));
          p_erb_minfin_row.isOverflow := json_value(p_response_body,'$.isOverflow');

          if p_erb_minfin_row.num_rows > 0
          then  
                for k in (
                          SELECT t.num_id,
                                 t.root_id,
                                 p_convert.convert_str(t.lastname,'CL8MSWIN1251','UTF8') as lastname,
                                 p_convert.convert_str(t.firstname,'CL8MSWIN1251','UTF8') as firstname,
                                 p_convert.convert_str(t.middlename,'CL8MSWIN1251','UTF8') as middlename,
                                 trunc(p_convert.get_datetime(t.birthdate)) as birthdate,
                                 p_convert.convert_str(t.publisher,'CL8MSWIN1251','UTF8') as publisher,
                                 p_convert.convert_str(t.departmentcode,'CL8MSWIN1251','UTF8') as departmentcode,
                                 p_convert.convert_str(t.departmentname,'CL8MSWIN1251','UTF8') as departmentname,
                                 p_convert.convert_str(t.departmentphone,'CL8MSWIN1251','UTF8') as departmentphone,
                                 p_convert.convert_str(t.executor,'CL8MSWIN1251','UTF8') as executor,
                                 p_convert.convert_str(t.executorphone,'CL8MSWIN1251','UTF8') as executorphone,
                                 p_convert.convert_str(t.executoremail,'CL8MSWIN1251','UTF8') as executoremail,
                                 p_convert.convert_str(t.deductiontype,'CL8MSWIN1251','UTF8') as deductiontype,
                                 p_convert.convert_str(t.vpnum,'CL8MSWIN1251','UTF8') as vpnum,
                                 p_convert.convert_str(t.okpo,'CL8MSWIN1251','UTF8') as okpo,
                                 p_convert.convert_str(t.full_name,'CL8MSWIN1251','UTF8') as full_name    
                            from json_table(p_response_body, '$.results[*]' 
                                   columns(
                                            num_id              number         path '$.ID',
                                            root_id             number         path '$.rootID',
                                            lastname            varchar2(4000) path '$.lastName',
                                            firstname           varchar2(4000) path '$.firstName',
                                            middlename          varchar2(4000) path '$.middleName',
                                            birthdate           varchar2(255)  path '$.birthDate',
                                            publisher           varchar2(4000) path '$.publisher',
                                            departmentcode      varchar2(4000) path '$.departmentCode',
                                            departmentname      varchar2(4000) path '$.departmentName',
                                            departmentphone     varchar2(4000) path '$.departmentPhone',
                                            executor            varchar2(4000) path '$.executor',
                                            executorphone       varchar2(4000) path '$.executorPhone',
                                            executoremail       varchar2(4000) path '$.executorEmail',
                                            deductiontype       varchar2(4000) path '$.deductionType',
                                            vpnum               varchar2(4000) path '$.vpNum',
                                            okpo                varchar2(255)  path '$.code',
                                            full_name           varchar2(4000) path '$.name'
                                           )) t
                        )                   
                 loop
                    p_erb_minfin_row.num_id          := k.num_id;
                    p_erb_minfin_row.root_id         := k.root_id;
                    p_erb_minfin_row.lastname        := k.lastname;
                    p_erb_minfin_row.firstname       := k.firstname;
                    p_erb_minfin_row.middlename      := k.middlename;
                    p_erb_minfin_row.birthdate       := k.birthdate;
                    p_erb_minfin_row.publisher       := k.publisher;
                    p_erb_minfin_row.departmentcode  := k.departmentcode;
                    p_erb_minfin_row.departmentname  := k.departmentname;
                    p_erb_minfin_row.departmentphone := k.departmentphone;
                    p_erb_minfin_row.executor        := k.executor;
                    p_erb_minfin_row.executorphone   := k.executorphone;
                    p_erb_minfin_row.executoremail   := k.executoremail;
                    p_erb_minfin_row.deductiontype   := k.deductiontype;
                    p_erb_minfin_row.vpnum           := k.vpnum;
                    p_erb_minfin_row.okpo            := k.okpo;
                    p_erb_minfin_row.full_name       := k.full_name;
                    --
                    p_erb_minfin_table.extend;
                    p_erb_minfin_table(p_num) := p_erb_minfin_row;
                    p_num := p_num + 1;
                 end loop;
           else                                
              p_erb_minfin_table.extend;
              p_erb_minfin_table(p_num) := p_erb_minfin_row;
           end if;
       end if;

       return p_erb_minfin_table;
    end;

$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_interface.read_erb_minfin (p_categoryCode text default null, p_identCode text default null, p_lastName text default null, p_firstName text default null, p_middleName text default null, p_birthDate timestamp default null, p_type_cust_code text DEFAULT NULL) FROM PUBLIC;
-- End of Oracle package 'P_INTERFACE' declaration



-- Oracle package 'P_INTERFACE_PIPE' declaration, please edit to match PostgreSQL syntax.

DROP SCHEMA IF EXISTS p_interface_pipe CASCADE;
CREATE SCHEMA IF NOT EXISTS p_interface_pipe;

CREATE TYPE p_interface_pipe.type_fair_value_row AS (
calc_date         timestamp,
     cpcode            varchar(255),
     ccy               varchar(3),
     fair_value        numeric,
     ytm               numeric,
     clean_rate        numeric,
     cor_coef          numeric,
     maturity          timestamp,
     cor_coef_cash     numeric,
     notional          numeric,
     avr_rate          numeric,
     option_value      numeric,
     intrinsic_value   numeric,
     time_value        numeric,
     delta_per         numeric,
     delta_equ         numeric,
     dop               varchar(255)
    
);

CREATE TYPE p_interface_pipe.type_fair_value_table AS (type_fair_value_table p_interface_pipe.type_fair_value_row[]);


CREATE TYPE p_interface_pipe.type_isin_secur_row AS (
cpcode          varchar(255),
      nominal         numeric,                                      
      auk_proc        numeric,                                      
      pgs_date        timestamp,                                      
      razm_date       timestamp,                                      
      cptype          varchar(255),
      cpdescr         varchar(255),
      pay_period      numeric,                                      
      val_code        varchar(3),                                      
      emit_okpo       varchar(255),
      emit_name       varchar(255),
      cptype_nkcpfr   varchar(255),
      cpcode_cfi      varchar(255),
      total_bonds     numeric,
      pay_date        timestamp,
      pay_type        numeric,
      pay_val         numeric,
      pay_array       varchar(5)  
    
);

CREATE TYPE p_interface_pipe.type_isin_secur_table AS (type_isin_secur_table p_interface_pipe.type_isin_secur_row[]);


CREATE TYPE p_interface_pipe.type_kurs_nbu_row AS (
r030         varchar(3),
     txt          varchar(255),
     rate         numeric,
     cc           varchar(3),
     exchangedate timestamp
    
);

CREATE TYPE p_interface_pipe.type_kurs_nbu_table AS (type_kurs_nbu_table p_interface_pipe.type_kurs_nbu_row[]);


CREATE TYPE p_interface_pipe.type_erb_minfin_row AS (
isSuccess       varchar(5),
     num_rows        numeric,
     requestDate     timestamp,
     isOverflow      varchar(5),
     num_id          numeric,
     root_id         numeric,
     lastname        varchar(4000),
     firstname       varchar(4000),
     middlename      varchar(4000),
     birthdate       varchar(255),
     publisher       varchar(4000),
     departmentcode  varchar(4000),
     departmentname  varchar(4000),
     departmentphone varchar(4000),
     executor        varchar(4000),
     executorphone   varchar(4000),
     executoremail   varchar(4000),
     deductiontype   varchar(4000),
     vpnum           varchar(4000),
     okpo            varchar(255),
     full_name       varchar(4000) 
    
);

CREATE TYPE p_interface_pipe.type_erb_minfin_table AS (type_erb_minfin_table p_interface_pipe.type_erb_minfin_row[]);




-- Справедливая стоимость ЦБ (котировки НБУ)
    -- Получить данные
    -- select f.* from table (p_interface_pipe.read_fair_value(p_date => to_date('09.04.2021','dd.mm.yyyy'))) f
CREATE OR REPLACE FUNCTION p_interface_pipe.read_fair_value (p_date timestamp -- дата
) RETURNS SETOF TYPE_FAIR_VALUE_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_fair_value_row       type_fair_value_row;

  j RECORD;
  k RECORD;

BEGIN
      p_url := 'https://bank.gov.ua/files/Fair_value/'||to_char(p_date,'yyyymm/yyyymmdd')||'_fv.txt';

      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'GET',
                   p_header_body_charset => 'WINDOWS-1251',
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
      --dbms_output.put_line(p_response_body);
      
      for j in (WITH RECURSIVE cte AS (

                with tt as (SELECT p_response_body || chr(13)||chr(10) as str )
                PERFORM (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^'||chr(13)||chr(10)||']+', 'g') AS foo(a) LIMIT 1 OFFSET (level - 1)) as string_row, row_number() OVER () as num
                from tt
                coalesce(regexp_instr(str, '[^'||chr(13)||chr(10)||']+', 1, level), 0) <> 0
                  UNION ALL

                with tt as (SELECT p_response_body || chr(13)||chr(10) as str )
                PERFORM (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^'||chr(13)||chr(10)||']+', 'g') AS foo(a) LIMIT 1 OFFSET (level - 1)) as string_row, row_number() OVER () as num
                from tt
                coalesce(regexp_instr(str, '[^'||chr(13)||chr(10)||']+', 1, level), 0) <> 0
                 JOIN cte c ON ()

) SELECT * FROM cte;
)
      loop    
          -- заголовок пропускаем
          if j.num = 1 then continue; end if;

          for k in (
                    with tt as (SELECT j.string_row || ';' as str )
                    PERFORM p_convert.str_to_date((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (1 - 1))) as calc_date,
                           (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (2 - 1)) as cpcode,
                           (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (3 - 1)) as ccy,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (4 - 1))) as fair_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (5 - 1))) as ytm,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (6 - 1))) as clean_rate,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (7 - 1))) as cor_coef,
                           p_convert.str_to_date((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (8 - 1))) as maturity,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (9 - 1))) as cor_coef_cash,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (10 - 1))) as notional,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (11 - 1))) as avr_rate,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (12 - 1))) as option_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (13 - 1))) as intrinsic_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (14 - 1))) as time_value,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (15 - 1))) as delta_per,
                           p_convert.str_to_num((SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (16 - 1))) as delta_equ,
                           (SELECT array_to_string(a, '') FROM regexp_matches(str, '[^;]+', 'g') AS foo(a) LIMIT 1 OFFSET (17 - 1)) as dop
                    from tt
                    )
           loop
              p_fair_value_row.calc_date := k.calc_date;
              p_fair_value_row.cpcode := k.cpcode;
              p_fair_value_row.ccy := k.ccy;
              p_fair_value_row.fair_value := k.fair_value;
              p_fair_value_row.ytm := k.ytm;
              p_fair_value_row.clean_rate := k.clean_rate;
              p_fair_value_row.cor_coef := k.cor_coef;
              p_fair_value_row.maturity := k.maturity;
              p_fair_value_row.cor_coef_cash := k.cor_coef_cash;
              p_fair_value_row.notional := k.notional;
              p_fair_value_row.avr_rate := k.avr_rate;
              p_fair_value_row.option_value := k.option_value;
              p_fair_value_row.intrinsic_value := k.intrinsic_value;
              p_fair_value_row.time_value := k.time_value;
              p_fair_value_row.delta_per := k.delta_per;
              p_fair_value_row.delta_equ := k.delta_equ;
              p_fair_value_row.dop := k.dop;
              RETURN NEXT p_fair_value_row;
           end loop;
       end loop;

       return;
    end;

    -- Перечень ISIN ЦБ с купонными периодами
    -- Получить данные
    -- select f.* from table (p_interface.read_isin_secur(p_format => 'json')) f;        
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION p_interface_pipe.read_fair_value (p_date timestamp ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_interface_pipe.read_isin_secur (p_format text -- формат xml, json
) RETURNS SETOF TYPE_ISIN_SECUR_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_dop_param            varchar(5);
      p_isin_secur_row       type_isin_secur_row;

  k RECORD;
  kk RECORD;

BEGIN
      if p_format = 'json' then p_dop_param := '?json'; end if;
      p_url := 'https://bank.gov.ua/depo_securities'||p_dop_param;

      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'GET',
                   p_header_content_type => case when p_format = 'json' then 'application/json' else 'text/xml' end,
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
       --dbms_output.put_line(p_response_body);
       
       if p_format = 'json'            
       then
          if p_check.is_valid_json(p_response_body) = 'T'
          then  
              for k in (
                       SELECT t.cpcode,
                              t.nominal,                                      
                              p_convert.str_to_num(t.auk_proc) as auk_proc,
                              p_convert.str_to_date(t.pgs_date) as pgs_date,
                              p_convert.str_to_date(t.razm_date) as razm_date,
                              t.cptype,
                              t.cpdescr,
                              t.pay_period,                                      
                              t.val_code,                                      
                              t.emit_okpo,
                              t.emit_name,
                              t.cptype_nkcpfr,
                              t.cpcode_cfi,
                              t.total_bonds,
                              t.payments
                          from json_table(p_response_body, '$[*]'
                                           columns                 
                                              cpcode          varchar2(255) path '$.cpcode',
                                              nominal         integer       path '$.nominal',                                      
                                              auk_proc        varchar2(255) path '$.auk_proc',                                      
                                              pgs_date        varchar2(255) path '$.pgs_date',                                      
                                              razm_date       varchar2(255) path '$.razm_date',                                      
                                              cptype          varchar2(255) path '$.cptype',
                                              cpdescr         varchar2(255) path '$.cpdescr',
                                              pay_period      integer       path '$.pay_period',                                      
                                              val_code        varchar2(3)   path '$.val_code',                                      
                                              emit_okpo       varchar2(255) path '$.emit_okpo',
                                              emit_name       varchar2(255) path '$.emit_name',
                                              cptype_nkcpfr   varchar2(255) path '$.cptype_nkcpfr',
                                              cpcode_cfi      varchar2(255) path '$.cpcode_cfi',
                                              total_bonds     integer       path '$.pay_period',                                          
                                              payments        FORMAT JSON   path '$.payments'                                          
                                            ) t  
                         )
               loop             
                  if k.payments is null
                  then  
                      p_isin_secur_row.cpcode := k.cpcode;
                      p_isin_secur_row.nominal := k.nominal;
                      p_isin_secur_row.auk_proc := k.auk_proc;
                      p_isin_secur_row.pgs_date := k.pgs_date;
                      p_isin_secur_row.razm_date := k.razm_date;
                      p_isin_secur_row.cptype := k.cptype;
                      p_isin_secur_row.cpdescr := k.cpdescr;
                      p_isin_secur_row.pay_period := k.pay_period;
                      p_isin_secur_row.val_code := k.val_code;
                      p_isin_secur_row.emit_okpo := k.emit_okpo;
                      p_isin_secur_row.emit_name := k.emit_name;
                      p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                      p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                      p_isin_secur_row.total_bonds := k.total_bonds;
                      p_isin_secur_row.pay_date := null;
                      p_isin_secur_row.pay_type := null;
                      p_isin_secur_row.pay_val := null;
                      p_isin_secur_row.pay_array := null;
                      RETURN NEXT p_isin_secur_row;
                  else
                      -- периоды
                      for kk in (
                                 SELECT p_convert.str_to_date(t.pay_date) as pay_date,
                                        t.pay_type,                                      
                                        p_convert.str_to_num(t.pay_val) as pay_val,
                                        t.pay_array
                                    from json_table(k.payments, '$[*]'
                                                     columns                 
                                                        pay_date        varchar2(255) path '$.pay_date',
                                                        pay_type        integer       path '$.pay_type',                                      
                                                        pay_val         varchar2(255) path '$.pay_val',                                      
                                                        pay_array       varchar2(255) path '$.array'
                                                      ) t  
                                )
                      loop          
                          p_isin_secur_row.cpcode := k.cpcode;
                          p_isin_secur_row.nominal := k.nominal;
                          p_isin_secur_row.auk_proc := k.auk_proc;
                          p_isin_secur_row.pgs_date := k.pgs_date;
                          p_isin_secur_row.razm_date := k.razm_date;
                          p_isin_secur_row.cptype := k.cptype;
                          p_isin_secur_row.cpdescr := k.cpdescr;
                          p_isin_secur_row.pay_period := k.pay_period;
                          p_isin_secur_row.val_code := k.val_code;
                          p_isin_secur_row.emit_okpo := k.emit_okpo;
                          p_isin_secur_row.emit_name := k.emit_name;
                          p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                          p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                          p_isin_secur_row.total_bonds := k.total_bonds;
                          p_isin_secur_row.pay_date := kk.pay_date;
                          p_isin_secur_row.pay_type := kk.pay_type;
                          p_isin_secur_row.pay_val := kk.pay_val;
                          p_isin_secur_row.pay_array := kk.pay_array;
                          RETURN NEXT p_isin_secur_row;
                      end loop;
                   end if;
               end loop;
           end if;
       else
          if p_check.is_valid_xml(p_response_body) = 'T'
          then  
              for k in (
                       SELECT t.cpcode,
                              t.nominal,                                      
                              p_convert.str_to_num(t.auk_proc) as auk_proc,
                              p_convert.str_to_date(t.pgs_date) as pgs_date,
                              p_convert.str_to_date(t.razm_date) as razm_date,
                              t.cptype,
                              t.cpdescr,
                              t.pay_period,                                      
                              t.val_code,                                      
                              t.emit_okpo,
                              t.emit_name,
                              t.cptype_nkcpfr,
                              t.cpcode_cfi,
                              t.total_bonds,
                              t.payments
                          from xmltable('//security' passing xmltype(p_response_body)
                                           columns                 
                                              cpcode          varchar2(255) path 'cpcode',
                                              nominal         integer       path 'nominal',                                      
                                              auk_proc        varchar2(255) path 'auk_proc',                                      
                                              pgs_date        varchar2(255) path 'pgs_date',                                      
                                              razm_date       varchar2(255) path 'razm_date',                                      
                                              cptype          varchar2(255) path 'cptype',
                                              cpdescr         varchar2(255) path 'cpdescr',
                                              pay_period      integer       path 'pay_period',                                      
                                              val_code        varchar2(3)   path 'val_code',                                      
                                              emit_okpo       varchar2(255) path 'emit_okpo',
                                              emit_name       varchar2(255) path 'emit_name',
                                              cptype_nkcpfr   varchar2(255) path 'cptype_nkcpfr',
                                              cpcode_cfi      varchar2(255) path 'cpcode_cfi',
                                              total_bonds     integer       path 'pay_period',                                          
                                              payments        xmltype       path 'payments'
                                            ) t  
                         )
               loop             
                  if k.payments is null
                  then  
                      p_isin_secur_row.cpcode := k.cpcode;
                      p_isin_secur_row.nominal := k.nominal;
                      p_isin_secur_row.auk_proc := k.auk_proc;
                      p_isin_secur_row.pgs_date := k.pgs_date;
                      p_isin_secur_row.razm_date := k.razm_date;
                      p_isin_secur_row.cptype := k.cptype;
                      p_isin_secur_row.cpdescr := k.cpdescr;
                      p_isin_secur_row.pay_period := k.pay_period;
                      p_isin_secur_row.val_code := k.val_code;
                      p_isin_secur_row.emit_okpo := k.emit_okpo;
                      p_isin_secur_row.emit_name := k.emit_name;
                      p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                      p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                      p_isin_secur_row.total_bonds := k.total_bonds;
                      p_isin_secur_row.pay_date := null;
                      p_isin_secur_row.pay_type := null;
                      p_isin_secur_row.pay_val := null;
                      p_isin_secur_row.pay_array := null;
                      RETURN NEXT p_isin_secur_row;
                  else
                      -- периоды
                      for kk in (
                                 SELECT p_convert.str_to_date(t.pay_date) as pay_date,
                                        t.pay_type,                                      
                                        p_convert.str_to_num(t.pay_val) as pay_val,
                                        t.pay_array
                                    from xmltable('//payment' passing k.payments
                                                     columns                 
                                                        pay_date        varchar2(255) path 'pay_date',
                                                        pay_type        integer       path 'pay_type',                                      
                                                        pay_val         varchar2(255) path 'pay_val',                                      
                                                        pay_array       varchar2(255) path 'array'
                                                      ) t  
                                )
                      loop          
                          p_isin_secur_row.cpcode := k.cpcode;
                          p_isin_secur_row.nominal := k.nominal;
                          p_isin_secur_row.auk_proc := k.auk_proc;
                          p_isin_secur_row.pgs_date := k.pgs_date;
                          p_isin_secur_row.razm_date := k.razm_date;
                          p_isin_secur_row.cptype := k.cptype;
                          p_isin_secur_row.cpdescr := k.cpdescr;
                          p_isin_secur_row.pay_period := k.pay_period;
                          p_isin_secur_row.val_code := k.val_code;
                          p_isin_secur_row.emit_okpo := k.emit_okpo;
                          p_isin_secur_row.emit_name := k.emit_name;
                          p_isin_secur_row.cptype_nkcpfr := k.cptype_nkcpfr;
                          p_isin_secur_row.cpcode_cfi := k.cpcode_cfi;
                          p_isin_secur_row.total_bonds := k.total_bonds;
                          p_isin_secur_row.pay_date := kk.pay_date;
                          p_isin_secur_row.pay_type := kk.pay_type;
                          p_isin_secur_row.pay_val := kk.pay_val;
                          p_isin_secur_row.pay_array := kk.pay_array;
                          RETURN NEXT p_isin_secur_row;
                      end loop;
                   end if;
               end loop;
           end if;
       end if;

       return;
    end;

    -- Курсы валют НБУ
    -- Получить данные
    -- select f.* from table (p_interface_pipe.read_kurs_nbu(p_date => to_date('09.04.2021','dd.mm.yyyy'), p_format => 'json', p_currency => 'USD')) f;
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_interface_pipe.read_isin_secur (p_format text ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_interface_pipe.read_kurs_nbu (p_date timestamp, -- дата курсов
 p_format text, -- формат xml, json
 p_currency text default null  -- UAH, USD, EUR
) RETURNS SETOF TYPE_KURS_NBU_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_dop_param            varchar(5);
      p_kurs_nbu_row         type_kurs_nbu_row;

  k RECORD;

BEGIN
      if p_format = 'json' then p_dop_param := '&json'; end if;

      if p_currency is null
      then  
         p_url := 'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?date='||to_char(p_date,'yyyymmdd')||p_dop_param;
      else
         p_url := 'https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange?valcode='||p_currency||'&date='||to_char(p_date,'yyyymmdd')||p_dop_param;
      end if;

      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'GET',
                   p_header_content_type => case when p_format = 'json' then 'application/json' else 'text/xml' end,
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
       --dbms_output.put_line(p_response_body);
       
       if p_format = 'json'            
       then
          if p_check.is_valid_json(p_response_body) = 'T'
          then  
              for k in (
                        SELECT lpad(j.r030,3,'0') as r030,
                               j.txt,
                               p_convert.str_to_num(j.rate) as rate,
                               j.cc,
                               p_convert.str_to_date(j.exchangedate) as exchangedate
                          from json_table(p_response_body, '$[*]' 
                                 columns(
                                         r030 varchar2(3)   path '$.r030',
                                         txt  varchar2(255) path '$.txt',
                                         rate varchar2(255) path '$.rate',                       
                                         cc   varchar2(255) path '$.cc',                       
                                         exchangedate varchar2(255) path '$.exchangedate'                       
                                         )) j
                         where j.r030 is not null and
                               j.txt  is not null and
                               j.rate is not null and
                               j.cc   is not null and
                               j.exchangedate is not null
                         )
               loop
                  p_kurs_nbu_row.r030 := k.r030;
                  p_kurs_nbu_row.txt := k.txt;
                  p_kurs_nbu_row.rate := k.rate;
                  p_kurs_nbu_row.cc := k.cc;
                  p_kurs_nbu_row.exchangedate := k.exchangedate;
                  RETURN NEXT p_kurs_nbu_row;
               end loop;
           end if;
       else
          if p_check.is_valid_xml(p_response_body) = 'T'
          then  
              for k in (
                        SELECT lpad(j.r030,3,'0') as r030,
                               j.txt,
                               p_convert.str_to_num(j.rate) as rate,
                               j.cc,
                               p_convert.str_to_date(j.exchangedate) as exchangedate
                          from xmltable('//exchange/currency' passing xmltype(p_response_body)
                                 columns 
                                         r030 varchar2(3)   path 'r030',
                                         txt  varchar2(255) path 'txt',
                                         rate varchar2(255) path 'rate',                       
                                         cc   varchar2(255) path 'cc',                       
                                         exchangedate varchar2(255) path 'exchangedate'                       
                                         ) j
                         where j.r030 is not null and
                               j.txt  is not null and
                               j.rate is not null and
                               j.cc   is not null and
                               j.exchangedate is not null
                         )
               loop
                  p_kurs_nbu_row.r030 := k.r030;
                  p_kurs_nbu_row.txt := k.txt;
                  p_kurs_nbu_row.rate := k.rate;
                  p_kurs_nbu_row.cc := k.cc;
                  p_kurs_nbu_row.exchangedate := k.exchangedate;
                  RETURN NEXT p_kurs_nbu_row;
               end loop;
           end if;
       end if;

       return;
    end;

    -- НАИС - поиск контрагента в ЕРД (едином реестре должников)
    -- Получить данные
    -- select f.* from table (p_interface_pipe.read_erb_minfin(p_identCode => '33270581', p_type_cust_code => '2')) f;    
    -- select f.* from table (p_interface_pipe.read_erb_minfin(p_identCode => '2985108376', p_type_cust_code => '1')) f;
    -- select f.* from table (p_interface_pipe.read_erb_minfin(p_lastName       => 'Бондарчук',
    --                                                         p_firstName      => 'Ігор',
    --                                                         p_middleName     => 'Володимирович',
    --                                                         p_birthDate      => to_date('23.09.1981','dd.mm.yyyy'),
    --                                                         p_type_cust_code => '1')) f;
$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_interface_pipe.read_kurs_nbu (p_date timestamp, p_format text, p_currency text default null  ) FROM PUBLIC;



CREATE OR REPLACE FUNCTION p_interface_pipe.read_erb_minfin (p_categoryCode text default null, -- пусто все, 03 - аллименты
 p_identCode text default null, p_lastName text default null, p_firstName text default null, p_middleName text default null, p_birthDate timestamp default null, p_type_cust_code text -- (1 - физ., 2 - юр.)
  DEFAULT NULL) RETURNS SETOF TYPE_ERB_MINFIN_TABLE AS $body$
DECLARE

      p_url                  varchar(255);
      p_wallet_file          varchar(255);
      p_wallet_file_pwd      varchar(255);
      p_response_body        text;
      p_response_status_code numeric;
      p_response_status_desc varchar(255);
      p_type_erb_minfin_row  type_erb_minfin_row;
      p_request_body         text;

  k RECORD;

BEGIN
      p_url := 'https://erb.minjust.gov.ua/listDebtorsEndpoint';

      -- физ. лица
      if p_type_cust_code = '1'
      then  
          select JSON_OBJECT('searchType' value '1',
                             'paging'     value '1',
                             'filter'     value JSON_OBJECT('LastName'     value p_convert.screening_json(p_convert.convert_str(p_lastName,'UTF8','CL8MSWIN1251')),
                                                            'FirstName'    value p_convert.screening_json(p_convert.convert_str(p_firstName,'UTF8','CL8MSWIN1251')),
                                                            'MiddleName'   value p_convert.screening_json(p_convert.convert_str(p_middleName,'UTF8','CL8MSWIN1251')),
                                                            'BirthDate'    value case when p_birthDate is null then null
                                                                                      else to_char(p_birthDate,'YYYY-MM-DD')||'T00:00:00.000Z'
                                                                                 end,       
                                                            'IdentCode'    value p_identCode,
                                                            'categoryCode' value p_categoryCode
                                                            --absent on null -- если будет пустая переменная, тег не подставляется
                                                            null on null -- по умолчанию, если пустая передается null, можно не прописывать
                                                       )                   
                            )
                        into STRICT p_request_body                 
;
      else
      -- юр. лица        
          select JSON_OBJECT('searchType' value '2',
                             'filter'     value JSON_OBJECT('FirmName'     value p_convert.screening_json(p_convert.convert_str(p_lastName,'UTF8','CL8MSWIN1251')),
                                                            'FirmEdrpou'   value p_identCode,
                                                            'categoryCode' value p_categoryCode
                                                       )                   
                            )
                        into STRICT p_request_body                 
;
      end if;
      
      read_wallet_param(p_wallet_file => p_wallet_file, p_wallet_file_pwd => p_wallet_file_pwd);
      
      -- запрашиваем данные
      http_request(p_url => p_url,
                   p_url_method => 'POST',
                   p_header_content_type => 'json',
                   p_wallet_file => p_wallet_file,
                   p_wallet_file_pwd => p_wallet_file_pwd,
                   p_transfer_timeout => 60,
                   p_header_body_charset => 'WINDOWS-1251',
                   p_request_body => p_request_body,
                   p_response_body => p_response_body,
                   p_response_status_code => p_response_status_code,
                   p_response_status_desc => p_response_status_desc);
       
       --dbms_output.put_line(p_request_body);      
       --dbms_output.put_line(p_response_body);
       --raise_application_error(-20000, p_request_body, true);           
       --raise_application_error(-20000, p_response_body, true);           
       
       if json_value(p_response_body,'$.errMsg') is not null
       then  
          RAISE EXCEPTION '%', p_request_body||chr(13)||chr(10)||json_value(p_response_body,'$.errMsg') USING ERRCODE = '45000';
       end if;

      if p_check.is_valid_json(p_response_body) = 'T'
      then   
          p_type_erb_minfin_row.isSuccess := json_value(p_response_body,'$.isSuccess');
          p_type_erb_minfin_row.num_rows := json_value(p_response_body,'$.rows');
          p_type_erb_minfin_row.requestDate := p_convert.get_datetime(json_value(p_response_body,'$.requestDate'));
          p_type_erb_minfin_row.isOverflow := json_value(p_response_body,'$.isOverflow');

          if p_type_erb_minfin_row.num_rows > 0
          then  
                for k in (
                          SELECT t.num_id,
                                 t.root_id,
                                 p_convert.convert_str(t.lastname,'CL8MSWIN1251','UTF8') as lastname,
                                 p_convert.convert_str(t.firstname,'CL8MSWIN1251','UTF8') as firstname,
                                 p_convert.convert_str(t.middlename,'CL8MSWIN1251','UTF8') as middlename,
                                 trunc(p_convert.get_datetime(t.birthdate)) as birthdate,
                                 p_convert.convert_str(t.publisher,'CL8MSWIN1251','UTF8') as publisher,
                                 p_convert.convert_str(t.departmentcode,'CL8MSWIN1251','UTF8') as departmentcode,
                                 p_convert.convert_str(t.departmentname,'CL8MSWIN1251','UTF8') as departmentname,
                                 p_convert.convert_str(t.departmentphone,'CL8MSWIN1251','UTF8') as departmentphone,
                                 p_convert.convert_str(t.executor,'CL8MSWIN1251','UTF8') as executor,
                                 p_convert.convert_str(t.executorphone,'CL8MSWIN1251','UTF8') as executorphone,
                                 p_convert.convert_str(t.executoremail,'CL8MSWIN1251','UTF8') as executoremail,
                                 p_convert.convert_str(t.deductiontype,'CL8MSWIN1251','UTF8') as deductiontype,
                                 p_convert.convert_str(t.vpnum,'CL8MSWIN1251','UTF8') as vpnum,
                                 p_convert.convert_str(t.okpo,'CL8MSWIN1251','UTF8') as okpo,
                                 p_convert.convert_str(t.full_name,'CL8MSWIN1251','UTF8') as full_name    
                            from json_table(p_response_body, '$.results[*]' 
                                   columns(
                                            num_id              number         path '$.ID',
                                            root_id             number         path '$.rootID',
                                            lastname            varchar2(4000) path '$.lastName',
                                            firstname           varchar2(4000) path '$.firstName',
                                            middlename          varchar2(4000) path '$.middleName',
                                            birthdate           varchar2(255)  path '$.birthDate',
                                            publisher           varchar2(4000) path '$.publisher',
                                            departmentcode      varchar2(4000) path '$.departmentCode',
                                            departmentname      varchar2(4000) path '$.departmentName',
                                            departmentphone     varchar2(4000) path '$.departmentPhone',
                                            executor            varchar2(4000) path '$.executor',
                                            executorphone       varchar2(4000) path '$.executorPhone',
                                            executoremail       varchar2(4000) path '$.executorEmail',
                                            deductiontype       varchar2(4000) path '$.deductionType',
                                            vpnum               varchar2(4000) path '$.vpNum',
                                            okpo                varchar2(255)  path '$.code',
                                            full_name           varchar2(4000) path '$.name'
                                           )) t
                        )                   
                 loop
                    p_type_erb_minfin_row.num_id          := k.num_id;
                    p_type_erb_minfin_row.root_id         := k.root_id;
                    p_type_erb_minfin_row.lastname        := k.lastname;
                    p_type_erb_minfin_row.firstname       := k.firstname;
                    p_type_erb_minfin_row.middlename      := k.middlename;
                    p_type_erb_minfin_row.birthdate       := k.birthdate;
                    p_type_erb_minfin_row.publisher       := k.publisher;
                    p_type_erb_minfin_row.departmentcode  := k.departmentcode;
                    p_type_erb_minfin_row.departmentname  := k.departmentname;
                    p_type_erb_minfin_row.departmentphone := k.departmentphone;
                    p_type_erb_minfin_row.executor        := k.executor;
                    p_type_erb_minfin_row.executorphone   := k.executorphone;
                    p_type_erb_minfin_row.executoremail   := k.executoremail;
                    p_type_erb_minfin_row.deductiontype   := k.deductiontype;
                    p_type_erb_minfin_row.vpnum           := k.vpnum;
                    p_type_erb_minfin_row.okpo            := k.okpo;
                    p_type_erb_minfin_row.full_name       := k.full_name;
                    RETURN NEXT p_type_erb_minfin_row;
                 end loop;
           else                                
              RETURN NEXT p_type_erb_minfin_row;
           end if;
       end if;

       return;
    end;

$body$
LANGUAGE PLPGSQL
 STABLE;
-- REVOKE ALL ON FUNCTION p_interface_pipe.read_erb_minfin (p_categoryCode text default null, p_identCode text default null, p_lastName text default null, p_firstName text default null, p_middleName text default null, p_birthDate timestamp default null, p_type_cust_code text DEFAULT NULL) FROM PUBLIC;
-- End of Oracle package 'P_INTERFACE_PIPE' declaration

